<!DOCTYPE html>
<!-- saved from url=(0014)about:internet -->
<html lang="en">
<head>
<title>Advanced character</title>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="IE=11" />
<meta http-equiv="Pragma" content="no-cache">

<style>
body { 
    margin: 0; padding: 0; border: 0;
    background: #808080;
    color:#FFF;
}
</style>

<!-- three -->
<script src="./js/three.js"></script>
<script src="./js/controls/OrbitControls.js"></script>
<!-- sea3d -->
<script src="./js/loaders/sea3d/SEA3D.js"></script>
<script src="./js/loaders/sea3d/SEA3DLoader.js"></script>
<script src="./js/loaders/sea3d/SEA3DLZMA.js"></script>
<script src="./js/loaders/sea3d/SEA3DLegacy.js"></script>
<!-- bvh -->
<script src="./js/loaders/BVHLoader.js"></script>
<!-- lth -->
<script src="./js/lth/BVHLoader_Add.js"></script>
<script src="./js/lth/Skeleton_Add.js"></script>
<script src="./js/lth/Eyes.js"></script>
</head>
<body>
<script>

var clock, camera, scene, renderer, controler, textureLoader, ground, bvhLoader, eyes;
var meshs = {};

init();
animate();
addGroundAndLight();
loadModel();

function init() {

	clock = new THREE.Clock();

	renderer = new THREE.WebGLRenderer( { antialias: true } );
	renderer.setPixelRatio( window.devicePixelRatio );
	renderer.setSize( window.innerWidth, window.innerHeight );
	renderer.shadowMap.enabled = true;
    renderer.shadowMap.soft = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    renderer.setClearColor( 0x808080, 1 );

    renderer.gammaInput = true;
    renderer.gammaOutput = true;
    renderer.toneMapping = THREE.ACESFilmicToneMapping;
    renderer.toneMappingExposure = 1;

	document.body.appendChild( renderer.domElement );
	renderer.domElement.style.position = "absolute";

	scene = new THREE.Scene();

	camera = new THREE.PerspectiveCamera( 50, window.innerWidth / window.innerHeight, 1, 1000 );
	camera.position.set( 0, 60, 160 );

	controler = new THREE.OrbitControls( camera, renderer.domElement );
	controler.target.set( 0, 40, 0 );
    controler.screenSpacePanning = true;
    controler.update();

	window.addEventListener( 'resize', resize, false );

	renderer.domElement.addEventListener( 'dragover', function(e){ e.preventDefault() }, false );
    renderer.domElement.addEventListener( 'dragend', function(e){ e.preventDefault() }, false );
    renderer.domElement.addEventListener( 'dragleave', function(e){ e.preventDefault()}, false );
    renderer.domElement.addEventListener( 'drop', dropAnimation, false );

	textureLoader = new THREE.TextureLoader();

}

function resize() {

	camera.aspect = window.innerWidth / window.innerHeight;
	camera.updateProjectionMatrix();
	renderer.setSize( window.innerWidth, window.innerHeight );

}

function animate() {

	requestAnimationFrame( animate );
	var delta = clock.getDelta();
	THREE.SEA3D.AnimationHandler.update( delta );
	renderer.render( scene, camera );

}

function addGroundAndLight () {

	var ambient = new THREE.HemisphereLight( 0x601010, 0xDDEEFF, 0.1 );
	scene.add( ambient );

	var light = new THREE.DirectionalLight( 0xffffff, 1 );
    light.position.set( 50, 300, 200 );
    
    light.shadow = new THREE.LightShadow( new THREE.OrthographicCamera( 300, -300, 300, -300,  100, 600 ) );
    light.shadow.mapSize.width = light.shadow.mapSize.height = 2048;    
    light.shadow.bias = 0.001;
    light.shadow.radius = 2;
    light.castShadow = true;
    scene.add( light );

	var groundMaterial = new THREE.ShadowMaterial({ opacity:0.3, depthTest:true, depthWrite:false });
	ground = new THREE.Mesh( new THREE.PlaneBufferGeometry( 1000, 1000, 1, 1 ), groundMaterial );
    ground.geometry.applyMatrix( new THREE.Matrix4().makeRotationX( -Math.PI*0.5 ) );
    ground.position.y = 1;
    ground.castShadow = false;
    ground.receiveShadow = true;
    ground.visible = false;
    scene.add( ground );

}

function loadTexture ( url, flip ) {

	var texture = textureLoader.load( url );
	if( flip !== undefined ) texture.flipY = flip;
	return texture;

}

function loadModel () {

	var loader = new THREE.SEA3D()
	loader.onComplete = function () {

		var i = loader.meshes.length, m;
		while( i-- ){

			m = loader.meshes[i];
			meshs[ m.name ] = m;
			scene.add( m );

		}

		var envmap = loadTexture( './assets/textures/envmap.jpg' );
		envmap.mapping = THREE.SphericalReflectionMapping;

		// make texture
		meshs.Armature.material = new THREE.MeshBasicMaterial({ wireframe:true, skinning:true });
		meshs.Body.material = new THREE.MeshStandardMaterial({ map:loadTexture( './assets/textures/body.jpg', false ), skinning:true, envMap:envmap, metalness:0.5, roughness:0.65, shadowSide:false });
		meshs.Head.material = new THREE.MeshStandardMaterial({ map:loadTexture( './assets/textures/head.jpg', false ), skinning:true, morphTargets:true, envMap:envmap, metalness:0.5, roughness:0.65, shadowSide:false });
		meshs.Head_plus.material = new THREE.MeshStandardMaterial({ 
			map:loadTexture( './assets/textures/head_plus.jpg', false ),
			alphaMap:loadTexture( './assets/textures/head_plus_m.jpg', false ), 
			skinning:true, morphTargets:true, envMap:envmap, metalness:0.8, roughness:0.2, shadowSide:false 
		});

		meshs.Head_plus.material.onBeforeCompile = function ( shader ) {
			var fragment = shader.fragmentShader;
			fragment = fragment.replace( '#include <dithering_fragment>', ['float RR = diffuseColor.a;', 'if ( RR < 0.5 ) { discard; }', ''].join("\n") );
			shader.fragmentShader = fragment;
		}

		meshs.Head.setWeight( "smile_open", 1 );

		addEyes();

		ground.visible = true;

		initBVH();

	};

	loader.load( './assets/models/matti.sea' );

}

function initBVH () {

	bvhLoader = new THREE.BVHLoader();
	bvhLoader.addModel( meshs.Armature );

	// set skeleton reference, only meshs.Armature have animation
	meshs.Body.skeleton.setReference( meshs.Armature.skeleton );
	meshs.Head.skeleton.setReference( meshs.Armature.skeleton );
	meshs.Head_plus.skeleton.setReference( meshs.Armature.skeleton );


	bvhLoader.load( "./assets/bvh/ClubDance.bvh", function ( result ) { result.name = "ClubDance"; addAnimation( result ); } )

}

function addAnimation( result ) {

    result.clip.name = result.name;
    var seq =  [];
    var pos = new THREE.Vector3( 0, 0 ,0 );

    bvhLoader.applyToModel( meshs.Armature, result, seq, pos );

    meshs.Armature.play( result.name );

}

function dropAnimation( e ){

    e.preventDefault();

    if (e.dataTransfer.items) {

        var file = e.dataTransfer.files[0];

    } else return;

    var reader = new FileReader();
    var fname = file.name;
    var type = fname.substring(fname.lastIndexOf('.')+1, fname.length );
    var name = fname.substring(0,fname.lastIndexOf('.') );

    if ( type === 'bvh' || type === 'BVH' ) reader.readAsText( file );
    else return;

    reader.onload = function ( e ) {

    	var result = bvhLoader.parseData( e.target.result );
    	result.name = name
        addAnimation( result );

    };

}

function addEyes () {

	eyes = new Eyes();
	scene.add(eyes);
	attachToBone(eyes, 'head');

}

function attachToBone( mesh, boneName ){

	var bones = meshs.Armature.skeleton.bones, b;
	for(var i = 0, lng = bones.length; i < lng; i++ ){
		b = bones[i];
		if( b.name === boneName ){
			mesh.matrix = b.matrixWorld;
			mesh.matrixAutoUpdate = false;
		}
	}

}

</script>
</body>
</html>